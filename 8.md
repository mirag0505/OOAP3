<<<<<<< ours

Я если правильно понял, то создание иирархии -- это испольщование:
или наследования
или композиции
или полиморфизма? (вот тут странно это звучит, но я же могу в качестве дженерика передавать обьекты другого класса -- это же связь?)

1.
abstract class GameState
// конструктор
// постусловие: создана новая стейт машина
public GameState GameState();

// команды:
// предусловие: выбранное состояние валидно
// предусловие: в выбранное состояние можно перейти 
// постусловие: стейт машина сменила свое состояние
public void transitionTo(string state);

// предусловие: надо ли проверять что-то?
// постусловие: выполняет пользовательскую команду
public void handleUserAction(action);

// запросы:
// постусловие: получем текущий статус
public void getCurrenState();
// статусы: (подумать, как хранить)
Инциализация
Меню (Выбрать: поменять местами ячейки, использовать бонус)
Процесс игры
Конец игры

2. 
У меня есть класс Grid и класс Cell -- обьединяю их одним КЛАСТЕРОМ? Dashboard?
Не понимаю, как это сделать, пока. Создавать эти сущности в одно класссе дашборд? А зачем? 
Они, вроде, и порознь могу жить. Можно, конечно, через дженерик передавать Cell. Не понимаю.

abstract class Dashboard (как-то должен обелинять в кластер Grid + Cell)

abstract class Grid
// конструктор
// постусловие: создано новое поле
public Grid Grid();

команды:
// предусловие: все ячейки существую
// постусловие: ячейки поменялись местами
public swapCells(x1, y1, x2, y2)

// предусловие: работает только при инициализации Grid
// постусловие: все ячейки пустые
public fillEmptyCells() -- а надо ли оно? инициализация же начинается с заполненых ячеек?

// предусловие: у Grid есть пустые ячейки
// постусловие: все пустые ячейки -- заполнены НЕ пустыми ячейками
public fillFullCells()

// предусловие: 
// постусловие: получили стринг всего грида для вывода
public generateGridString()

// предусловие: хотябы две ячейки должны находиться на поле + наверно они должны быть рядом, а надо ли это ваще проверять?)
// постусловие: получили список всех ВЫИГРЫШНЫХ комбинаций
public findMatches()

// запросы:


abstract class Cell
// конструктор
// постусловие: создана новая пустая или не пустая клетка
public Cell Cell(string type);

// предусловие: эта ИМЕННО бонусная ячейка
// постусловие: активирован бонус
public activateBonus()

// запросы:
// статусы:
type: пустая, заполненая -> обычная, бонусная

3. UserInterface
abstract class UserInterface (как-то должен обьединять в кластер Input + Output)

abstract class Input
// конструктор
// постусловие: создан Input
public Input Input();

команды:
// предусловие: все ячейки существую
// постусловие: ячейки поменялись местами
public InputHandler(string str)
валидация?
выполнение команд из меню?

abstract class Output
// конструктор
// постусловие: создан Output
public Output Output();

команды:
// предусловие: не пустой вывод
// постусловие: отображение в консоли вывода
public OutputRenderer(string str)

4. Statistics
abstract class Statistics
// конструктор
// постусловие: создан Statistics
public Statistics Statistics();

команды:
// предусловие:
// постусловие: запись шага в историю
public addStep(action)

// предусловие: 
// постусловие: обновление очков
public updateScore(points)

// предусловие: данные не пусты
// постусловие: подготовка статистики для вывода (в виде строки).
public getFormattedStats() — 

// статусы:
number stepsCount — количество шагов.
number score — количество очков.
Array Actions[] history — история шагов (массив объектов с действиями).

5. Bonus
abstract class Bonus
// конструктор
// постусловие: создан Bonus
public Bonus Bonus();

// постусловие: применение бонуса к ячейке ячейке
public applyBonusEffect(cell, grid)

// стаутсы
type: взрыв по горизонатил/вертикали, взрыв крестом

6. GameLogic
abstract class GameLogic

public GameLogic GameLogic();
// конструктор
// постусловие: создан GameLogic

// предусловие: возможно ли это?
// постусловие: применение обмена ячеек
public applySwap(x1, y1, x2, y2)

// предусловие: возможно ли это?
// постусловие: удаление ВЫИГРЫШНЫХ коминаций и начисление очков (моно на две операции поделить)
public resolveMatches()

// предусловие: возможно ли это?
// постусловие: применение бонуса
public activateBonus(x, y)

// предусловие: нет возможных ходов
// постусловие: проверка на окончание игры
public checkGameOver()

7. Command
abstract class Command

public Command Command();
// конструктор
// постусловие: создан Command

// предусловие: возможно ли это?
// постусловие: применение команды
public execute() — выполнение действия.

Здесь еще есть, что доделать -- и статусы, и запросы, я переоцинил свои силы :)

--------------------------------
Шаблон для АТД:
abstract class HashTable
// конструктор
public HashTable<T> HashTable(int sz);
// инварианты (для всего класса/обьекта целиком)

// постусловие (команды обязательны, конструктор?, запроса?)
// предусловие (запросы обязательны, конструктор?, команды)

// команды (модифицирует данные)
public void remove(T value);
// запросы (получает/проверяет данные или заправшивает статусы)
public int get_intersection_status();
// статусы
public const int POP_NIL = 0; 












2. Grid
Хранение данных о ячейках, логика игры
Grid + Cell

3. UserInterface
Input + Output

4. Statistics
5. Bonus
6. GameLogic
здесь будут храниться игровые правила и логика
управялет тем, КАКИЕ действия будут выполнены
7. Command
здесь будут команды, которые я буду выполнять в GameLogic (хотя не уверен, что их нужно разделять, и можно все сделать просто в Grid или в той же GameLogic)

С одной стороны усложнение, раз мы доп. сущности добавляем, а с другой, этим проще будет управлять.
|||||||
=======

Я если правильно понял, то создание иирархии -- это испольщование:
или наследования
или композиции
или полиморфизма? (вот тут странно это звучит, но я же могу в качестве дженерика передавать обьекты другого класса -- это же связь?)

1.
abstract class GameState
// конструктор
// постусловие: создана новая стейт машина
public GameState GameState();

// команды:
// предусловие: выбранное состояние валидно
// предусловие: в выбранное состояние можно перейти 
// постусловие: стейт машина сменила свое состояние
public void transitionTo(string state);

// предусловие: надо ли проверять что-то?
// постусловие: выполняет пользовательскую команду
public void handleUserAction(action);

// запросы:
// постусловие: получем текущий статус
public void getCurrenState();
// статусы: (подумать, как хранить)
Инциализация
Меню (Выбрать: поменять местами ячейки, использовать бонус)
Процесс игры
Конец игры

2. 
У меня есть класс Grid и класс Cell -- обьединяю их одним КЛАСТЕРОМ? Dashboard?
Не понимаю, как это сделать, пока. Создавать эти сущности в одно класссе дашборд? А зачем? 
Они, вроде, и порознь могу жить. Можно, конечно, через дженерик передавать Cell. Не понимаю.

abstract class Dashboard (как-то должен обелинять в кластер Grid + Cell)

abstract class Grid
// конструктор
// постусловие: создано новое поле
public Grid Grid();

команды:
// предусловие: все ячейки существую
// постусловие: ячейки поменялись местами
public swapCells(x1, y1, x2, y2)

// предусловие: работает только при инициализации Grid
// постусловие: все ячейки пустые
public fillEmptyCells() -- а надо ли оно? инициализация же начинается с заполненых ячеек?

// предусловие: у Grid есть пустые ячейки
// постусловие: все пустые ячейки -- заполнены НЕ пустыми ячейками
public fillFullCells()

// предусловие: 
// постусловие: получили стринг всего грида для вывода
public generateGridString()

// предусловие: хотябы две ячейки должны находиться на поле + наверно они должны быть рядом, а надо ли это ваще проверять?)
// постусловие: получили список всех ВЫИГРЫШНЫХ комбинаций
public findMatches()

// запросы:


abstract class Cell
// конструктор
// постусловие: создана новая пустая или не пустая клетка
public Cell Cell(string type);

// предусловие: эта ИМЕННО бонусная ячейка
// постусловие: активирован бонус
public activateBonus()

// запросы:
// статусы:
type: пустая, заполненая -> обычная, бонусная

3. UserInterface
abstract class UserInterface (как-то должен обьединять в кластер Input + Output)

abstract class Input
// конструктор
// постусловие: создан Input
public Input Input();

команды:
// предусловие: все ячейки существую
// постусловие: ячейки поменялись местами
public InputHandler(string str)
валидация?
выполнение команд из меню?

abstract class Output
// конструктор
// постусловие: создан Output
public Output Output();

команды:
// предусловие: не пустой вывод
// постусловие: отображение в консоли вывода
public OutputRenderer(string str)

4. Statistics
abstract class Statistics
// конструктор
// постусловие: создан Statistics
public Statistics Statistics();

команды:
// предусловие:
// постусловие: запись шага в историю
public addStep(action)

// предусловие: 
// постусловие: обновление очков
public updateScore(points)

// предусловие: данные не пусты
// постусловие: подготовка статистики для вывода (в виде строки).
public getFormattedStats() — 

// статусы:
number stepsCount — количество шагов.
number score — количество очков.
Array Actions[] history — история шагов (массив объектов с действиями).

5. Bonus
abstract class Bonus
// конструктор
// постусловие: создан Bonus
public Bonus Bonus();

// постусловие: применение бонуса к ячейке ячейке
public applyBonusEffect(cell, grid)

// стаутсы
type: взрыв по горизонатил/вертикали, взрыв крестом

6. GameLogic
abstract class GameLogic

public GameLogic GameLogic();
// конструктор
// постусловие: создан GameLogic

// предусловие: возможно ли это?
// постусловие: применение обмена ячеек
public applySwap(x1, y1, x2, y2)

// предусловие: возможно ли это?
// постусловие: удаление ВЫИГРЫШНЫХ коминаций и начисление очков (моно на две операции поделить)
public resolveMatches()

// предусловие: возможно ли это?
// постусловие: применение бонуса
public activateBonus(x, y)

// предусловие: нет возможных ходов
// постусловие: проверка на окончание игры
public checkGameOver()

7. Command
abstract class Command

public Command Command();
// конструктор
// постусловие: создан Command

// предусловие: возможно ли это?
// постусловие: применение команды
public execute() — выполнение действия.

Здесь еще есть, что доделать -- и статусы, и запросы, я переоцинил свои силы :)

--------------------------------
Шаблон для АТД:
abstract class HashTable
// конструктор
public HashTable<T> HashTable(int sz);
// инварианты (для всего класса/обьекта целиком)

// постусловие (команды обязательны, конструктор?, запроса?)
// предусловие (запросы обязательны, конструктор?, команды)

// команды (модифицирует данные)
public void remove(T value);
// запросы (получает/проверяет данные или заправшивает статусы)
public int get_intersection_status();
// статусы
public const int POP_NIL = 0; 












2. Grid
Хранение данных о ячейках, логика игры
Grid + Cell

3. UserInterface
Input + Output

4. Statistics
5. Bonus
6. GameLogic
здесь будут храниться игровые правила и логика
управялет тем, КАКИЕ действия будут выполнены
7. Command
здесь будут команды, которые я буду выполнять в GameLogic (хотя не уверен, что их нужно разделять, и можно все сделать просто в Grid или в той же GameLogic)

С одной стороны усложнение, раз мы доп. сущности добавляем, а с другой, этим проще будет управлять.
>>>>>>> theirs
