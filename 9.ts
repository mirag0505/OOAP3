Сейчас я добавлю класс который будет все эти отдельные использовать классы

0.
abstract class GameFactory
// конструктор
// постусловие: создан экземпляр игры
public GameFactory GameFactory();

// команды:
// предусловие: все начальные значения заданы корректно, хотя как это проверять? и надо ли? этим же кадый класс по отдельности занимается?
// постусловие: создан экзепляр игры, можно играть
public createGame() 
Предусловие: Все необходимые конфигурационные параметры заданы корректно.
Постусловие: Возвращается объект Game, состоящий из инициализированных компонентов:
            - GameState (начальное состояние "Инициализация")
            - Grid (игровое поле с заполнением случайными элементами)
            - UserInterface (интерфейс ввода/вывода)
            - GameLogic (логика игры: обмен ячеек, разрешение матчей, активация бонусов)
            - Statistics (начальные очки, история ходов)
            - Bonus (механика бонусов)
Вот написал, и думаю, а точно ли он нужен этот обьединяющщий класс?

1.
abstract class GameState
// конструктор
// постусловие: создана новая стейт машина
public GameState GameState();

// команды:
// предусловие: выбранное состояние валидно
// предусловие: в выбранное состояние можно перейти 
// постусловие: стейт машина сменила свое состояние
public void transitionTo(string state);

// предусловие: проверить можно ли из одного статуса переходить в другой. Например: запрещено из инициализации переходить в конец игры
// постусловие: меняем текущее состояние на теруемое
public void handleUserAction(action);

// запросы:
// постусловие: получем текущий статус
public void getCurrenState();
// статусы: (подумать, как хранить)
Инциализация
Меню (Выбрать: поменять местами ячейки, использовать бонус)
Процесс игры
Конец игры

2. 
abstract class Dashboard (как-то должен обелинять в кластер Grid + Cell)

// конструктор
// постусловие: создано Grid c Cell
public Dashboard Dashboard();

команды:
// постусловие: что-то изменилось в Гриде, после действия (как это проверять?)
public updateGridAfterAction()

// запросы: 
// предусловие: сущствует экземпляр
// постусловие: получаем экземпляр
public getGrid() 

3.
abstract class Grid
// конструктор
// постусловие: создано новое поле
public Grid Grid();

команды:
// предусловие: все ячейки существую
// постусловие: ячейки поменялись местами
public swapCells(x1, y1, x2, y2)

// предусловие: работает только при инициализации Grid
// постусловие: все ячейки пустые
public fillEmptyCells() -- а надо ли оно? инициализация же начинается с заполненых ячеек?

// предусловие: у Grid есть пустые ячейки
// постусловие: все пустые ячейки -- заполнены НЕ пустыми ячейками
public fillFullCells()

// предусловие: 
// постусловие: получили стринг всего грида для вывода
public generateGridString()

// предусловие: хотябы две ячейки должны находиться на поле + наверно они должны быть рядом, а надо ли это ваще проверять?)
// постусловие: получили список всех ВЫИГРЫШНЫХ комбинаций
public findMatches()

// запросы:
// предусловие: существует ли CEll?
// постусловие: получаем экземпляр
public getCell() 

4.
abstract class Cell
// конструктор
// постусловие: создана новая пустая или не пустая клетка
public Cell Cell(string type);

// команды
// предусловие: эта ИМЕННО бонусная ячейка
// постусловие: активирован бонус
public activateBonus()

// запросы:
// постусловие: получаем статус ячейки
public getStatus() 
// статусы:
type: пустая, заполненая -> обычная, бонусная

5. UserInterface
abstract class UserInterface (как-то должен обьединять в кластер Input + Output)

abstract class UserInterface
// конструктор
// постусловие: создан UserInterface
public UserInterface UserInterface();

// команды
// предусловие: output не пустой.
// постусловие: Строка output выведена в консоль.
renderOutput(output: string)

// статусы
// постусловие: Считывается строка ввода пользователя.
getInput() : string
(надо в нужных местах не забыть длобавить команды на создание строки для вывода)

6.
abstract class Input
// конструктор
// постусловие: создан Input
public Input Input();

команды:
// постусловие: пользователь ввел данные и они попали в программу
public InputHandler(string str)
валидация? (потом)
выполнение команд из меню? (потом)

7.
abstract class Output
// конструктор
// постусловие: создан Output
public Output Output();

команды:
// предусловие: не пустой вывод
// постусловие: отображение в консоли вывода
public OutputRenderer(string str)

8. Statistics
abstract class Statistics
// конструктор
// постусловие: создан Statistics
public Statistics Statistics();

команды:
// предусловие:
// постусловие: запись шага в историю
public addStep(action)

// предусловие: 
// постусловие: обновление очков
public updateScore(points)

// предусловие: данные не пусты
// постусловие: подготовка статистики для вывода (в виде строки).
public getFormattedStats() 

// запросы
// предусловие что они существую

// инварианты?
они должны быть не меньше нуля!
publick getStepsCount
publick getScore
publick getHistory

// статусы:
number stepsCount — количество шагов.
number score — количество очков.
Array Actions[] history — история шагов (массив объектов с действиями).

9. Bonus
abstract class Bonus
// конструктор
// постусловие: создан Bonus
public Bonus Bonus();

// постусловие: применение бонуса к ячейке ячейке
public applyBonusEffect(cell, grid)

// запрос
public getStatus
// стаутсы
type: взрыв по горизонатил/вертикали, взрыв крестом

10. GameLogic
abstract class GameLogic

public GameLogic GameLogic();
// конструктор
// постусловие: создан GameLogic

// предусловие: возможно ли это?
// постусловие: применение обмена ячеек
public applySwap(x1, y1, x2, y2)

// предусловие: возможно ли это?
// постусловие: удаление ВЫИГРЫШНЫХ коминаций и начисление очков (моно на две операции поделить)
public resolveMatches()

// предусловие: возможно ли это?
// постусловие: применение бонуса
public activateBonus(x, y)

// предусловие: нет возможных ходов
// постусловие: проверка на окончание игры
public checkGameOver()

11. Command
abstract class Command

public Command Command();
// конструктор
// постусловие: создан Command

// предусловие: возможно ли это?
// постусловие: применение команды
public execute() — выполнение действия.
------------------------------------------

Я не буду использовать фреимворки, только натив, возхможно на TS или на С#. НЕ очень понимаю, как ловить реальные исключения, пока
Можно прописать для каждой команды статус, МОЖЕТ нужен отдельный класс для этого, так лень для всего это прописывать, капец, просто)

Типовые сценарии:
1: Обмен ячеек, приводящий к разрешению комбинаций
    Шаги:
      1. Создать игру через GameFactory.
      2. Выполнить swapCells(x1, y1, x2, y2).
      3. Вызвать resolveMatches().
      4. Проверить, что выигрышные комбинации удалены, пустые ячейки заполнены, статистика обновлена.

2: Активация бонуса
    Шаги:
      1. Создать игровое поле с бонусной ячейкой.
      2. Выполнить activateBonus(x, y).
      3. Проверить, что эффект бонуса корректно применяется (удаляются нужные ячейки) и статистика обновляется.

3: Проверка окончания игры
    Шаги:
      1. Создать игровую ситуацию без возможных ходов.
      2. Вызвать checkGameOver().
      3. Проверить, что метод возвращает true и GameState переходит в состояние "Конец игры".

Их много, но пусть будут пока эти хотя бы 


--------------------------------
Шаблон для АТД:
abstract class HashTable
// конструктор
public HashTable<T> HashTable(int sz);
// инварианты (для всего класса/обьекта целиком)

// постусловие (команды обязательны, конструктор?, запроса?)
// предусловие (запросы обязательны, конструктор?, команды)

// команды (модифицирует данные)
public void remove(T value);
// запросы (получает/проверяет данные или заправшивает статусы)
public int get_intersection_status();
// статусы
public const int POP_NIL = 0; 












2. Grid
Хранение данных о ячейках, логика игры
Grid + Cell

3. UserInterface
Input + Output

4. Statistics
5. Bonus
6. GameLogic
здесь будут храниться игровые правила и логика
управялет тем, КАКИЕ действия будут выполнены
7. Command
здесь будут команды, которые я буду выполнять в GameLogic (хотя не уверен, что их нужно разделять, и можно все сделать просто в Grid или в той же GameLogic)

С одной стороны усложнение, раз мы доп. сущности добавляем, а с другой, этим проще будет управлять.
|||||||
=======

Я если правильно понял, то создание иирархии -- это испольщование:
или наследования
или композиции
или полиморфизма? (вот тут странно это звучит, но я же могу в качестве дженерика передавать обьекты другого класса -- это же связь?)

1.
abstract class GameState
// конструктор
// постусловие: создана новая стейт машина
public GameState GameState();

// команды:
// предусловие: выбранное состояние валидно
// предусловие: в выбранное состояние можно перейти 
// постусловие: стейт машина сменила свое состояние
public void transitionTo(string state);

// предусловие: надо ли проверять что-то?
// постусловие: выполняет пользовательскую команду
public void handleUserAction(action);

// запросы:
// постусловие: получем текущий статус
public void getCurrenState();
// статусы: (подумать, как хранить)
Инциализация
Меню (Выбрать: поменять местами ячейки, использовать бонус)
Процесс игры
Конец игры

2. 
У меня есть класс Grid и класс Cell -- обьединяю их одним КЛАСТЕРОМ? Dashboard?
Не понимаю, как это сделать, пока. Создавать эти сущности в одно класссе дашборд? А зачем? 
Они, вроде, и порознь могу жить. Можно, конечно, через дженерик передавать Cell. Не понимаю.

abstract class Dashboard (как-то должен обелинять в кластер Grid + Cell)

abstract class Grid
// конструктор
// постусловие: создано новое поле
public Grid Grid();

команды:
// предусловие: все ячейки существую
// постусловие: ячейки поменялись местами
public swapCells(x1, y1, x2, y2)

// предусловие: работает только при инициализации Grid
// постусловие: все ячейки пустые
public fillEmptyCells() -- а надо ли оно? инициализация же начинается с заполненых ячеек?

// предусловие: у Grid есть пустые ячейки
// постусловие: все пустые ячейки -- заполнены НЕ пустыми ячейками
public fillFullCells()

// предусловие: 
// постусловие: получили стринг всего грида для вывода
public generateGridString()

// предусловие: хотябы две ячейки должны находиться на поле + наверно они должны быть рядом, а надо ли это ваще проверять?)
// постусловие: получили список всех ВЫИГРЫШНЫХ комбинаций
public findMatches()

// запросы:


abstract class Cell
// конструктор
// постусловие: создана новая пустая или не пустая клетка
public Cell Cell(string type);

// предусловие: эта ИМЕННО бонусная ячейка
// постусловие: активирован бонус
public activateBonus()

// запросы:
// статусы:
type: пустая, заполненая -> обычная, бонусная

3. UserInterface
abstract class UserInterface (как-то должен обьединять в кластер Input + Output)

abstract class Input
// конструктор
// постусловие: создан Input
public Input Input();

команды:
// предусловие: все ячейки существую
// постусловие: ячейки поменялись местами
public InputHandler(string str)
валидация?
выполнение команд из меню?

abstract class Output
// конструктор
// постусловие: создан Output
public Output Output();

команды:
// предусловие: не пустой вывод
// постусловие: отображение в консоли вывода
public OutputRenderer(string str)

4. Statistics
abstract class Statistics
// конструктор
// постусловие: создан Statistics
public Statistics Statistics();

команды:
// предусловие:
// постусловие: запись шага в историю
public addStep(action)

// предусловие: 
// постусловие: обновление очков
public updateScore(points)

// предусловие: данные не пусты
// постусловие: подготовка статистики для вывода (в виде строки).
public getFormattedStats() — 

// статусы:
number stepsCount — количество шагов.
number score — количество очков.
Array Actions[] history — история шагов (массив объектов с действиями).

5. Bonus
abstract class Bonus
// конструктор
// постусловие: создан Bonus
public Bonus Bonus();

// постусловие: применение бонуса к ячейке ячейке
public applyBonusEffect(cell, grid)

// стаутсы
type: взрыв по горизонатил/вертикали, взрыв крестом

6. GameLogic
abstract class GameLogic

public GameLogic GameLogic();
// конструктор
// постусловие: создан GameLogic

// предусловие: возможно ли это?
// постусловие: применение обмена ячеек
public applySwap(x1, y1, x2, y2)

// предусловие: возможно ли это?
// постусловие: удаление ВЫИГРЫШНЫХ коминаций и начисление очков (моно на две операции поделить)
public resolveMatches()

// предусловие: возможно ли это?
// постусловие: применение бонуса
public activateBonus(x, y)

// предусловие: нет возможных ходов
// постусловие: проверка на окончание игры
public checkGameOver()

7. Command
abstract class Command

public Command Command();
// конструктор
// постусловие: создан Command

// предусловие: возможно ли это?
// постусловие: применение команды
public execute() — выполнение действия.







--------------------------------
Шаблон для АТД:
abstract class HashTable
// конструктор
public HashTable<T> HashTable(int sz);
// инварианты (для всего класса/обьекта целиком)

// постусловие (команды обязательны, конструктор?, запроса?)
// предусловие (запросы обязательны, конструктор?, команды)

// команды (модифицирует данные)
public void remove(T value);
// запросы (получает/проверяет данные или заправшивает статусы)
public int get_intersection_status();
// статусы
public const int POP_NIL = 0; 
